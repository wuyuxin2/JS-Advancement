<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>工厂方法----构造函数</title>
    <script type="text/javascript">
      // 工厂方法：都是Object
      function createPerson(name, age, gender) {
        var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.gender = gender;
        obj.sayName = function() {
          alert(this.name);
        };
        return obj;
      }

      var obj2 = createPerson("sun", 28, "male");
      var obj3 = createPerson("bai", 18, "female");
      var obj4 = createPerson("zhi", 58, "male");

      console.log(obj2);

      // 构造函数————一类对象，创造实例
      /* 
        构造函数的执行流程：
            1.立即创建一个新的对象
            2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
            3.逐行执行函数中的代码
            4.将新建的对象作为返回值返回
        
        sayName是内部创建的，所有的实例的sayName都是唯一的，这样就导致了构造函数执行一次就创建一个新的方法
          - 执行100000次，就会创建100000个新的方法
          - 完全没有必要，可以共享一个方法
          - 将sayName在全局作用域中定义
    */
      function Person(name, age, gender) {
        // alert(this);
        this.name = name;
        this.age = age;
        this.gender = gender;
        // 向对象添加一个方法
        this.sayName = fun;
      }
      // 将sayName在全局作用域中定义
      /* 
        - 将函数定义在全局作用域，污染了全局作用域的命名空间
        - 而且定义在全局作用域中很不安全
      */
      function fun() {
        alert("hello,大家好，我是" + this.name);
      }

      var per = new Person("sun", 18, "male");

      console.log(per);
    </script>
  </head>
  <body></body>
</html>
